{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gabri/Documents/project/doc/next/user-management-app/lib/csvHandler.js"],"sourcesContent":["/*const fs = require('fs');\r\nconst path = require('path');\r\nconst { createObjectCsvWriter } = require('csv-writer');\r\nconst csv = require('csv-parser');\r\n\r\nconst CSV_FILE = path.join(process.cwd(), 'users.csv');\r\n\r\n// Initialize CSV file with headers if it doesn't exist\r\nconst initializeCSV = async () => {\r\n  try {\r\n    if (!fs.existsSync(CSV_FILE)) {\r\n      const csvWriter = createObjectCsvWriter({\r\n        path: CSV_FILE,\r\n        header: [\r\n          { id: 'id', title: 'ID' },\r\n          { id: 'uid', title: 'UID' },\r\n          { id: 'first_name', title: 'First Name' },\r\n          { id: 'last_name', title: 'Last Name' },\r\n          { id: 'username', title: 'Username' },\r\n          { id: 'email', title: 'Email' },\r\n          { id: 'phone_number', title: 'Phone Number' },\r\n          { id: 'date_of_birth', title: 'Date of Birth' }\r\n        ],\r\n        fieldDelimiter: ';'\r\n      });\r\n      await csvWriter.writeRecords([]);\r\n      console.log('CSV file initialized');\r\n    }\r\n  } catch (error) {\r\n    console.error('Error initializing CSV:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst readCSV = () => {\r\n  return new Promise((resolve, reject) => {\r\n    const results = [];\r\n    \r\n    if (!fs.existsSync(CSV_FILE)) {\r\n      return resolve([]);\r\n    }\r\n\r\n    fs.createReadStream(CSV_FILE)\r\n      .pipe(csv({ \r\n        separator: ';',\r\n        mapHeaders: ({ header }) => header.trim()\r\n      }))\r\n      .on('data', (data) => results.push(data))\r\n      .on('end', () => resolve(results))\r\n      .on('error', (error) => reject(error));\r\n  });\r\n};\r\n\r\nconst writeCSV = async (records) => {\r\n  const csvWriter = createObjectCsvWriter({\r\n    path: CSV_FILE,\r\n    header: [\r\n      { id: 'id', title: 'ID' },\r\n      { id: 'uid', title: 'UID' },\r\n      { id: 'first_name', title: 'First Name' },\r\n      { id: 'last_name', title: 'Last Name' },\r\n      { id: 'username', title: 'Username' },\r\n      { id: 'email', title: 'Email' },\r\n      { id: 'phone_number', title: 'Phone Number' },\r\n      { id: 'date_of_birth', title: 'Date of Birth' }\r\n    ],\r\n    fieldDelimiter: ';'\r\n  });\r\n\r\n  await csvWriter.writeRecords(records);\r\n};\r\n\r\nconst addUser = async (user) => {\r\n  try {\r\n    await initializeCSV();\r\n    const records = await readCSV();\r\n    \r\n    const newUser = {\r\n      id: (records.length + 1).toString(),\r\n      uid: user.uid,\r\n      first_name: user.first_name,\r\n      last_name: user.last_name,\r\n      username: user.username,\r\n      email: user.email,\r\n      phone_number: user.phone_number,\r\n      date_of_birth: user.date_of_birth\r\n    };\r\n    \r\n    records.push(newUser);\r\n    await writeCSV(records);\r\n    return newUser;\r\n  } catch (error) {\r\n    console.error('Error adding user to CSV:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst updateUser = async (id, updatedUser) => {\r\n  try {\r\n    const records = await readCSV();\r\n    const index = records.findIndex(record => record.id === id.toString());\r\n    \r\n    if (index !== -1) {\r\n      records[index] = { \r\n        ...records[index], \r\n        ...updatedUser,\r\n        id: records[index].id // Preserve original ID\r\n      };\r\n      await writeCSV(records);\r\n      return records[index];\r\n    }\r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error updating user:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst deleteUser = async (id) => {\r\n  try {\r\n    const records = await readCSV();\r\n    const filteredRecords = records.filter(record => record.id !== id.toString());\r\n    await writeCSV(filteredRecords);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting user:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst searchUsers = async (query, fields = ['first_name', 'last_name']) => {\r\n  try {\r\n    const records = await readCSV();\r\n    const lowerQuery = query.toLowerCase();\r\n    \r\n    return records.filter(record => \r\n      fields.some(field => \r\n        record[field] && record[field].toLowerCase().includes(lowerQuery)\r\n      )\r\n    );\r\n  } catch (error) {\r\n    console.error('Error searching users:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  initializeCSV,\r\n  readCSV,\r\n  addUser,\r\n  updateUser,\r\n  deleteUser,\r\n  searchUsers\r\n};*/\r\n// /lib/csvHandler.js\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst { createObjectCsvWriter } = require('csv-writer');\r\nconst csv = require('csv-parser');\r\n\r\nconst CSV_FILE = path.join(process.cwd(), 'users.csv');\r\n\r\n// Initialize CSV file with headers if it doesn't exist\r\nconst initializeCSV = async () => {\r\n  try {\r\n    if (!fs.existsSync(CSV_FILE)) {\r\n      const csvWriter = createObjectCsvWriter({\r\n        path: CSV_FILE,\r\n        header: [\r\n          { id: 'id', title: 'ID' },\r\n          { id: 'uid', title: 'UID' },\r\n          { id: 'first_name', title: 'First Name' },\r\n          { id: 'last_name', title: 'Last Name' },\r\n          { id: 'username', title: 'Username' },\r\n          { id: 'email', title: 'Email' },\r\n          { id: 'phone_number', title: 'Phone Number' },\r\n          { id: 'date_of_birth', title: 'Date of Birth' }\r\n        ],\r\n        append: false, // Don't append when creating initially\r\n        fieldDelimiter: ';'\r\n      });\r\n      await csvWriter.writeRecords([]);\r\n      console.log('CSV file initialized');\r\n    }\r\n  } catch (error) {\r\n    console.error('Error initializing CSV:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst readCSV = () => {\r\n  return new Promise((resolve, reject) => {\r\n    const results = [];\r\n    \r\n    if (!fs.existsSync(CSV_FILE)) {\r\n      return resolve([]);\r\n    }\r\n\r\n    fs.createReadStream(CSV_FILE)\r\n      .pipe(csv({ \r\n        separator: ';',\r\n        mapHeaders: ({ header }) => header.trim()\r\n      }))\r\n      .on('data', (data) => results.push(data))\r\n      .on('end', () => resolve(results))\r\n      .on('error', (error) => reject(error));\r\n  });\r\n};\r\n\r\n// FIXED: This function now properly reads existing data and writes everything back\r\nconst writeCSV = async (records) => {\r\n  const csvWriter = createObjectCsvWriter({\r\n    path: CSV_FILE,\r\n    header: [\r\n      { id: 'id', title: 'ID' },\r\n      { id: 'uid', title: 'UID' },\r\n      { id: 'first_name', title: 'First Name' },\r\n      { id: 'last_name', title: 'Last Name' },\r\n      { id: 'username', title: 'Username' },\r\n      { id: 'email', title: 'Email' },\r\n      { id: 'phone_number', title: 'Phone Number' },\r\n      { id: 'date_of_birth', title: 'Date of Birth' }\r\n    ],\r\n    append: false, // Important: This ensures we overwrite with ALL records\r\n    fieldDelimiter: ';'\r\n  });\r\n\r\n  await csvWriter.writeRecords(records);\r\n};\r\n\r\n// FIXED: This now properly handles ID generation and reads existing records\r\nconst addUser = async (user) => {\r\n  try {\r\n    await initializeCSV();\r\n    const records = await readCSV();\r\n    \r\n    // Generate unique ID - find the highest existing ID and increment\r\n    const maxId = records.length > 0 \r\n      ? Math.max(...records.map(r => parseInt(r.id) || 0)) \r\n      : 0;\r\n    \r\n    const newUser = {\r\n      id: (maxId + 1).toString(),\r\n      uid: user.uid || `user-${Date.now()}`,\r\n      first_name: user.first_name,\r\n      last_name: user.last_name,\r\n      username: user.username,\r\n      email: user.email,\r\n      phone_number: user.phone_number,\r\n      date_of_birth: user.date_of_birth\r\n    };\r\n    \r\n    // Add new user to existing records\r\n    records.push(newUser);\r\n    \r\n    // Write ALL records back to CSV (existing + new)\r\n    await writeCSV(records);\r\n    return newUser;\r\n  } catch (error) {\r\n    console.error('Error adding user to CSV:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst updateUser = async (id, updatedUser) => {\r\n  try {\r\n    const records = await readCSV();\r\n    const index = records.findIndex(record => record.id === id.toString());\r\n    \r\n    if (index !== -1) {\r\n      records[index] = { \r\n        ...records[index], \r\n        ...updatedUser,\r\n        id: records[index].id // Preserve original ID\r\n      };\r\n      await writeCSV(records); // This writes ALL records back\r\n      return records[index];\r\n    }\r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error updating user:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst deleteUser = async (id) => {\r\n  try {\r\n    const records = await readCSV();\r\n    const filteredRecords = records.filter(record => record.id !== id.toString());\r\n    await writeCSV(filteredRecords); // This writes remaining records back\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting user:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst searchUsers = async (query, fields = ['first_name', 'last_name']) => {\r\n  try {\r\n    const records = await readCSV();\r\n    const lowerQuery = query.toLowerCase();\r\n    \r\n    return records.filter(record => \r\n      fields.some(field => \r\n        record[field] && record[field].toLowerCase().includes(lowerQuery)\r\n      )\r\n    );\r\n  } catch (error) {\r\n    console.error('Error searching users:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  initializeCSV,\r\n  readCSV,\r\n  addUser,\r\n  updateUser,\r\n  deleteUser,\r\n  searchUsers\r\n};"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 386, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gabri/Documents/project/doc/next/user-management-app/pages/api/records.js"],"sourcesContent":["import { readCSV, updateUser, deleteUser, initializeCSV } from '../../lib/csvHandler';\r\n\r\nexport default async function handler(req, res) {\r\n  await initializeCSV();\r\n\r\n  switch (req.method) {\r\n    case 'GET':\r\n      try {\r\n        const records = await readCSV();\r\n        res.status(200).json(records);\r\n      } catch (error) {\r\n        res.status(500).json({ message: 'Error reading records', error: error.message });\r\n      }\r\n      break;\r\n\r\n    case 'PUT':\r\n      try {\r\n        const { id } = req.query;\r\n        const updatedUser = await updateUser(id, req.body);\r\n        if (!updatedUser) {\r\n          return res.status(404).json({ message: 'User not found' });\r\n        }\r\n        res.status(200).json(updatedUser);\r\n      } catch (error) {\r\n        res.status(500).json({ message: 'Error updating user', error: error.message });\r\n      }\r\n      break;\r\n\r\n    case 'DELETE':\r\n      try {\r\n        const { id } = req.query;\r\n        await deleteUser(id);\r\n        res.status(200).json({ message: 'User deleted successfully' });\r\n      } catch (error) {\r\n        res.status(500).json({ message: 'Error deleting user', error: error.message });\r\n      }\r\n      break;\r\n\r\n    default:\r\n      res.status(405).json({ message: 'Method not allowed' });\r\n  }\r\n}"],"names":[],"mappings":";;;;AAAA;;AAEe,eAAe,QAAQ,GAAG,EAAE,GAAG;IAC5C,MAAM,IAAA,2HAAa;IAEnB,OAAQ,IAAI,MAAM;QAChB,KAAK;YACH,IAAI;gBACF,MAAM,UAAU,MAAM,IAAA,qHAAO;gBAC7B,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YACvB,EAAE,OAAO,OAAO;gBACd,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,SAAS;oBAAyB,OAAO,MAAM,OAAO;gBAAC;YAChF;YACA;QAEF,KAAK;YACH,IAAI;gBACF,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,KAAK;gBACxB,MAAM,cAAc,MAAM,IAAA,wHAAU,EAAC,IAAI,IAAI,IAAI;gBACjD,IAAI,CAAC,aAAa;oBAChB,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;wBAAE,SAAS;oBAAiB;gBAC1D;gBACA,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YACvB,EAAE,OAAO,OAAO;gBACd,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,SAAS;oBAAuB,OAAO,MAAM,OAAO;gBAAC;YAC9E;YACA;QAEF,KAAK;YACH,IAAI;gBACF,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,KAAK;gBACxB,MAAM,IAAA,wHAAU,EAAC;gBACjB,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,SAAS;gBAA4B;YAC9D,EAAE,OAAO,OAAO;gBACd,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBAAE,SAAS;oBAAuB,OAAO,MAAM,OAAO;gBAAC;YAC9E;YACA;QAEF;YACE,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,SAAS;YAAqB;IACzD;AACF","debugId":null}}]
}